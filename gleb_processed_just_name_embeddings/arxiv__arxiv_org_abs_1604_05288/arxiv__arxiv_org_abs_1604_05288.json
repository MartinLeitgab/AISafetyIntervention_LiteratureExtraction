{
  "nodes": [
    {
      "name": "Incorrect probability estimates for unexecuted computations in AI systems",
      "aliases": [
        "miscalibrated logical uncertainty for expensive computations",
        "unreliable probability assignments about computation outputs"
      ],
      "type": "concept",
      "description": "AI agents that must reason about computations they cannot afford to run can make unsafe or sub-optimal decisions if their probability estimates are wrong.",
      "concept_category": "risk",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Introduction – motivation for assigning probabilities to costly computations."
    },
    {
      "name": "Arbitrary probability assignments in coherence-limit approximation schemes",
      "aliases": [
        "unconstrained finite approximations",
        "arbitrary beliefs prior to proof"
      ],
      "type": "concept",
      "description": "Approximation schemes that only converge to coherence in the limit can output essentially random probabilities for a statement until they manage to prove or refute it.",
      "concept_category": "problem analysis",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Introduction – critique of Demski-style limit-coherent approximations."
    },
    {
      "name": "Lack of pattern-based probability constraints leads to unsafe AI decisions",
      "aliases": [
        "delayed pattern recognition in approximations",
        "absence of early provability pattern use"
      ],
      "type": "concept",
      "description": "Without early recognition of provable relationships (e.g. mutual exclusivity), approximations may allocate probability mass inconsistently, harming downstream reasoning.",
      "concept_category": "problem analysis",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Inductive Coherence §2 – need to recognise patterns before running computations."
    },
    {
      "name": "Inductive coherence property ensuring early identification of provable patterns",
      "aliases": [
        "inductive coherence",
        "early-pattern logical coherence"
      ],
      "type": "concept",
      "description": "A strengthening of coherence requiring that any pattern in provability identifiable in polynomial time be reflected in the approximation not much later than the pattern-generator.",
      "concept_category": "theoretical insight",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Inductive Coherence §2 – formal definition and motivation."
    },
    {
      "name": "Exploiting polynomial-time provability patterns in approximation design",
      "aliases": [
        "pattern-oriented approximation design",
        "quick-pattern exploitation"
      ],
      "type": "concept",
      "description": "Design goal: make approximation schemes that automatically incorporate any provability pattern revealed by a polynomial-time algorithm, preventing arbitrary probabilities.",
      "concept_category": "design rationale",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Inductive Coherence §2 – rationale following definition."
    },
    {
      "name": "Modification of Demski's approximation scheme to incorporate inductive coherence",
      "aliases": [
        "scheme M*",
        "inductively coherent variant of Demski algorithm"
      ],
      "type": "concept",
      "description": "The paper adapts Demski’s limit-coherent algorithm, adding mechanisms that enforce inductive coherence while maintaining computability.",
      "concept_category": "design rationale",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "An Inductively Coherent Approximation Scheme §3 – overview of modifications."
    },
    {
      "name": "Simplicity-prior random Turing machine sampling to construct consistent extension T*",
      "aliases": [
        "random TM sampling with simplicity bias",
        "simplicity prior over theories"
      ],
      "type": "concept",
      "description": "M* samples Turing machines according to a simplicity prior; any machine whose output is consistent with the theory so far contributes its sentences, building a complete extension.",
      "concept_category": "implementation mechanism",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Algorithm 1 – construction of T* via random TM sampling."
    },
    {
      "name": "Con_n bounded consistency checking within approximation scheme",
      "aliases": [
        "Con_n function",
        "finite proof-bounded consistency test"
      ],
      "type": "concept",
      "description": "Before accepting a machine’s claims, M* uses the Con_n test: look for short proofs of inconsistency or pairwise contradictions within 2n proof length, ensuring finite-time safety.",
      "concept_category": "implementation mechanism",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Algorithm 2 – definition of Con_n and its role."
    },
    {
      "name": "Formal proof that M* is inductively coherent",
      "aliases": [
        "Theorem 6",
        "inductive coherence proof for M*"
      ],
      "type": "concept",
      "description": "Theorem 6 shows that the computable scheme M* satisfies all three inductive-coherence conditions, thereby meeting the strengthened requirement.",
      "concept_category": "validation evidence",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "§3 / Appendix – proof details establishing inductive coherence."
    },
    {
      "name": "Lemma: M* assigns high probability to quickly computable theorems",
      "aliases": [
        "Lemma 1 high-prob theorem recognition",
        "quick theorem probability lemma"
      ],
      "type": "concept",
      "description": "Lemma 1 demonstrates that, for any polynomial-time listable sequence of theorems, M*’s assigned probability converges to 1, confirming early pattern exploitation.",
      "concept_category": "validation evidence",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "§3 – supporting lemma under Theorem 6."
    },
    {
      "name": "Theorem: M* converges to coherent distribution P*",
      "aliases": [
        "convergence to P*",
        "limit coherence of M*"
      ],
      "type": "concept",
      "description": "Shows that despite being only inductively coherent at finite time, the limit of M*’s estimates forms a fully coherent distribution P*, ensuring eventual full logical consistency.",
      "concept_category": "validation evidence",
      "intervention_lifecycle": null,
      "intervention_lifecycle_rationale": null,
      "intervention_maturity": null,
      "intervention_maturity_rationale": null,
      "node_rationale": "Inductive Coherence Theorem 5 – coherence in the limit."
    },
    {
      "name": "Integrate inductively coherent approximation scheme M* into AI reasoning engines",
      "aliases": [
        "deploy M* in agent metareasoning",
        "use inductive coherence in decision systems"
      ],
      "type": "intervention",
      "description": "Embed the M* algorithm as the logical-uncertainty module of planning or verification systems so that agents maintain calibrated beliefs about computations they cannot yet run.",
      "concept_category": null,
      "intervention_lifecycle": "1",
      "intervention_lifecycle_rationale": "Applies during initial design of the agent’s reasoning architecture – see §3 ‘Approximation Scheme’.",
      "intervention_maturity": "2",
      "intervention_maturity_rationale": "Backed only by formal proofs; no large-scale empirical deployment – inferred from §3 and Conclusions.",
      "node_rationale": "Conclusions – proposed future work to use inductively coherent predictors."
    },
    {
      "name": "Apply inductive coherence constraints in probabilistic logic modules during metareasoning",
      "aliases": [
        "enforce inductive coherence in logical uncertainty modules",
        "design constraints for metareasoners"
      ],
      "type": "intervention",
      "description": "When designing new probabilistic logic frameworks, include inductive-coherence constraints so that any approximation quickly reflects polynomial-time provability patterns.",
      "concept_category": null,
      "intervention_lifecycle": "1",
      "intervention_lifecycle_rationale": "Constraint must be baked into module design specifications – derived from §2 definition.",
      "intervention_maturity": "1",
      "intervention_maturity_rationale": "Conceptual design guideline; implementation details remain open – inferred from theoretical discussion.",
      "node_rationale": "Conclusions – need for stronger future constraints on approximation schemes."
    }
  ],
  "edges": [
    {
      "type": "caused_by",
      "source_node": "Incorrect probability estimates for unexecuted computations in AI systems",
      "target_node": "Arbitrary probability assignments in coherence-limit approximation schemes",
      "description": "Risk arises because existing schemes can output arbitrary probabilities until proofs are found.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Explicit in Introduction – clear logical argument.",
      "edge_rationale": "Introduction – coherence-limit schemes admit arbitrary finite-time behaviour."
    },
    {
      "type": "caused_by",
      "source_node": "Incorrect probability estimates for unexecuted computations in AI systems",
      "target_node": "Lack of pattern-based probability constraints leads to unsafe AI decisions",
      "description": "Missing pattern constraints further underlies mis-estimation risk.",
      "edge_confidence": "3",
      "edge_confidence_rationale": "Synthesised from §2 discussion.",
      "edge_rationale": "Inductive Coherence §2 – emphasises necessity of pattern recognition."
    },
    {
      "type": "mitigated_by",
      "source_node": "Arbitrary probability assignments in coherence-limit approximation schemes",
      "target_node": "Inductive coherence property ensuring early identification of provable patterns",
      "description": "Introducing inductive coherence constrains approximations, preventing arbitrary assignments.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Direct claim in §2.",
      "edge_rationale": "Inductive Coherence definition and motivation."
    },
    {
      "type": "mitigated_by",
      "source_node": "Lack of pattern-based probability constraints leads to unsafe AI decisions",
      "target_node": "Inductive coherence property ensuring early identification of provable patterns",
      "description": "Inductive coherence adds exactly the missing pattern-based constraints.",
      "edge_confidence": "3",
      "edge_confidence_rationale": "Logical inference from §2.",
      "edge_rationale": "Same section."
    },
    {
      "type": "mitigated_by",
      "source_node": "Inductive coherence property ensuring early identification of provable patterns",
      "target_node": "Exploiting polynomial-time provability patterns in approximation design",
      "description": "Design principle derives from the property’s requirement to follow polynomial-time pattern generators.",
      "edge_confidence": "3",
      "edge_confidence_rationale": "Conceptual link articulated in §2.",
      "edge_rationale": "Inductive Coherence §2 – bound on lag relative to pattern-generator."
    },
    {
      "type": "implemented_by",
      "source_node": "Exploiting polynomial-time provability patterns in approximation design",
      "target_node": "Modification of Demski's approximation scheme to incorporate inductive coherence",
      "description": "Authors implement the design principle by modifying Demski’s scheme.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Explicit in §3 opening paragraphs.",
      "edge_rationale": "An Inductively Coherent Approximation Scheme §3."
    },
    {
      "type": "implemented_by",
      "source_node": "Modification of Demski's approximation scheme to incorporate inductive coherence",
      "target_node": "Simplicity-prior random Turing machine sampling to construct consistent extension T*",
      "description": "Random TM sampling is one concrete mechanism used in the modified scheme.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Algorithm 1 definition.",
      "edge_rationale": "Algorithm 1 description."
    },
    {
      "type": "implemented_by",
      "source_node": "Modification of Demski's approximation scheme to incorporate inductive coherence",
      "target_node": "Con_n bounded consistency checking within approximation scheme",
      "description": "Finite-proof bounded consistency test is the second key mechanism in the scheme.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Algorithm 2 definition.",
      "edge_rationale": "Algorithm 2 description."
    },
    {
      "type": "validated_by",
      "source_node": "Simplicity-prior random Turing machine sampling to construct consistent extension T*",
      "target_node": "Formal proof that M* is inductively coherent",
      "description": "Theorem 6 proves that the mechanism contributes to inductive coherence.",
      "edge_confidence": "5",
      "edge_confidence_rationale": "Formal proof provided.",
      "edge_rationale": "§3 / Appendix – proof references Algorithm 1."
    },
    {
      "type": "validated_by",
      "source_node": "Simplicity-prior random Turing machine sampling to construct consistent extension T*",
      "target_node": "Lemma: M* assigns high probability to quickly computable theorems",
      "description": "Lemma 1 analyses probability assignments resulting from the sampling mechanism.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Formal lemma.",
      "edge_rationale": "§3 – lemma applied to Algorithm 1 behaviour."
    },
    {
      "type": "validated_by",
      "source_node": "Simplicity-prior random Turing machine sampling to construct consistent extension T*",
      "target_node": "Theorem: M* converges to coherent distribution P*",
      "description": "Inductive coherence and the sampling mechanism ensure limit coherence.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Derived from Theorem 5 applied to M*.",
      "edge_rationale": "Theorem 5 discussion."
    },
    {
      "type": "validated_by",
      "source_node": "Con_n bounded consistency checking within approximation scheme",
      "target_node": "Formal proof that M* is inductively coherent",
      "description": "Con_n is essential in the inductive coherence proof.",
      "edge_confidence": "5",
      "edge_confidence_rationale": "Stated in proof of Theorem 6.",
      "edge_rationale": "§3 / Appendix."
    },
    {
      "type": "validated_by",
      "source_node": "Con_n bounded consistency checking within approximation scheme",
      "target_node": "Lemma: M* assigns high probability to quickly computable theorems",
      "description": "Lemma relies on bounded consistency to guarantee inclusion of theorem outputs.",
      "edge_confidence": "4",
      "edge_confidence_rationale": "Formal lemma.",
      "edge_rationale": "§3 – proof of lemma references Con_n."
    },
    {
      "type": "validated_by",
      "source_node": "Con_n bounded consistency checking within approximation scheme",
      "target_node": "Theorem: M* converges to coherent distribution P*",
      "description": "Bounded checks help secure convergence to coherence.",
      "edge_confidence": "3",
      "edge_confidence_rationale": "Argument in text; less direct than other proofs.",
      "edge_rationale": "Theorem 5 narrative."
    },
    {
      "type": "motivates",
      "source_node": "Formal proof that M* is inductively coherent",
      "target_node": "Integrate inductively coherent approximation scheme M* into AI reasoning engines",
      "description": "Proof gives confidence to deploy M* within AI systems.",
      "edge_confidence": "2",
      "edge_confidence_rationale": "Deployment suggestion inferred – not explicit.",
      "edge_rationale": "Conclusions – future work statement."
    },
    {
      "type": "motivates",
      "source_node": "Lemma: M* assigns high probability to quickly computable theorems",
      "target_node": "Integrate inductively coherent approximation scheme M* into AI reasoning engines",
      "description": "High-probability property suggests practical usefulness.",
      "edge_confidence": "2",
      "edge_confidence_rationale": "Inference from lemma.",
      "edge_rationale": "§3 / Conclusions."
    },
    {
      "type": "motivates",
      "source_node": "Theorem: M* converges to coherent distribution P*",
      "target_node": "Integrate inductively coherent approximation scheme M* into AI reasoning engines",
      "description": "Guarantee of limit coherence provides further deployment justification.",
      "edge_confidence": "2",
      "edge_confidence_rationale": "Inference.",
      "edge_rationale": "Theorem 5 / Conclusions."
    },
    {
      "type": "motivates",
      "source_node": "Formal proof that M* is inductively coherent",
      "target_node": "Apply inductive coherence constraints in probabilistic logic modules during metareasoning",
      "description": "Proof encourages adoption of inductive coherence as a design constraint.",
      "edge_confidence": "2",
      "edge_confidence_rationale": "Inference.",
      "edge_rationale": "Conclusions – need for stronger constraints."
    },
    {
      "type": "motivates",
      "source_node": "Lemma: M* assigns high probability to quickly computable theorems",
      "target_node": "Apply inductive coherence constraints in probabilistic logic modules during metareasoning",
      "description": "Empirical-style property motivates broader constraint adoption.",
      "edge_confidence": "2",
      "edge_confidence_rationale": "Inference.",
      "edge_rationale": "§3 / Conclusions."
    },
    {
      "type": "motivates",
      "source_node": "Theorem: M* converges to coherent distribution P*",
      "target_node": "Apply inductive coherence constraints in probabilistic logic modules during metareasoning",
      "description": "Limit coherence further supports using inductive coherence as a standard.",
      "edge_confidence": "2",
      "edge_confidence_rationale": "Inference.",
      "edge_rationale": "Theorem 5 / Conclusions."
    }
  ],
  "meta": [
    {
      "key": "date_published",
      "value": "2016-04-18T00:00:00Z"
    },
    {
      "key": "source",
      "value": "arxiv"
    },
    {
      "key": "title",
      "value": "Inductive Coherence"
    },
    {
      "key": "authors",
      "value": [
        "Scott Garrabrant",
        "Benya Fallenstein",
        "Abram Demski",
        "Nate Soares"
      ]
    },
    {
      "key": "url",
      "value": "https://arxiv.org/abs/1604.05288"
    }
  ]
}